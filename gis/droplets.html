<html>

<head>
    <title>Droplets</title>

    <link rel="stylesheet" href="https://cdn.skypack.dev/leaflet@1.8.0-beta.3/dist/leaflet.css">
    <!-- <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0-beta.3/dist/leaflet.css"> -->

    <style>
        * {
            padding: 0;
            margin: 0;
        }

        #map {
            height: 100vh
        }

        .terrain-pane .leaflet-tile {
            border: solid black 1px;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script type="module">
        import * as util from '../src/utils.js'

        import * as gis from '../src/gis.js'
        import * as TileData from '../src/TileData.js'
        import * as leafletUtils from './leafletUtils.js'
        import LeafletDataSet from './LeafletDataSet.js'

        import TwoDraw from '../src/TwoDraw.js'
        import Animator from '../src/Animator.js'
        import Model from '../models/DropletsModel.js'

        // import L from 'https://cdn.skypack.dev/leaflet@1.8.0-beta.3'
        import * as L from 'https://cdn.skypack.dev/leaflet@1.8.0-beta.3/dist/leaflet-src.esm.js'
        // import * as L from 'https://unpkg.com/leaflet@1.8.0-beta.3/dist/leaflet-src.esm.js'

        import elementOverlay from 'https://cdn.skypack.dev/@redfish/leafletelementoverlay'

        util.toWindow({ L, util, gis, LeafletDataSet, leafletUtils })


        const ElementOverlay = elementOverlay(L)
        const tileData = TileData['mapzen'] // redfishUSA/World, mapzen, mapbox
        const terrainName = 'topo'
        util.toWindow({ TileData, tileData, leafletUtils })

        // ================ setup parameters ================

        // let { X, Y, Z } = { X: 210, Y: 403, Z: 10 }
        // const bbox = gis.xyz2bbox(X, Y, Z)
        // const bboxCenter = gis.latlon(gis.bboxCenter(bbox))
        // console.log('XYZ', X, Y, Z, 'bbox', bbox, 'center', bboxCenter)
        // util.toWindow({ X, Y, Z })

        const center = [35.67, -105.93]
        const Z = 10

        // ================ create map with terrain & elevation ================

        const map = L.map('map', {
            zoomDelta: 0.25, //0.1
            zoomSnap: 0,
            // }).setView(bboxCenter, Z)
        }).setView(center, Z)

        const terrainLayer = L.tileLayer(gis.template(terrainName), {
            attribution: gis.attribution(terrainName),
            className: 'terrain-pane' // shows tiles borders
        }).addTo(map)

        const elevationLayer = L.tileLayer(
            tileData.zxyTemplate,
            {
                opacity: 0.1,
                // opacity: 1,
                attribution: 'Elevation Tiles',
                crossOrigin: '',
                maxZoom: tileData.maxZoom, // larger mapzen zoom yields tileerror
            }
        ).addTo(map)
        util.toWindow({ terrainLayer, elevationLayer, map })

        // ================ create dataset from bbox tiles ================

        let leafletDataSet = new LeafletDataSet(
            map,
            elevationLayer,
            tileData
        )
        leafletUtils.testEvents(map, elevationLayer)
        // leafletUtils.testZooms(elevationLayer)


        // let elementBounds = map.getBounds() // use either gis.bbox or leaflet latlng elementBounds
        // let bboxDataSet = await leafletDataSet.getBBoxDataSet(elementBounds)


        // ================ create model using bbox dataset ================

        var modelLayer, elementBounds = map.getBounds()
        async function setupModelView(elementBounds) {
            let bboxDataSet = await leafletDataSet.getBBoxDataSet(elementBounds)
            console.log('leafletDataSet', leafletDataSet, 'bboxDataSet', bboxDataSet)
            util.toWindow({ leafletDataSet, bboxDataSet, elementBounds })

            const model = new Model({
                minX: 0,
                minY: 0,
                maxX: Math.round(bboxDataSet.width / 4) - 1,
                maxY: Math.round(bboxDataSet.height / 4) - 1,
            })
            model.killOffworld = true // see if faster
            // await model.startup([Z, X, Y]) // TEST
            await model.startup(bboxDataSet)
            model.setup()
            const view = new TwoDraw(model, {
                div: util.createCanvas(0, 0), // the view will resize
                patchSize: 4,
                // useSprites: true,
                drawOptions: {
                    patchesColor: 'transparent',
                    turtlesShape: 'square',
                    turtlesRotate: false,
                    turtlesColor: 'red',
                    turtlesSize: 0.5, //1,
                },
            })
            // Note: when zooming happens after adding the canvas, remove the current one
            // and draw it on a new larger canvas with ctx.imageSmoothingEnabled = false
            if (modelLayer) modelLayer.remove()
            view.canvas.style.border = '1px red solid'
            modelLayer = new ElementOverlay(view.canvas, elementBounds).addTo(map)
            // const modelLayer = new ElementOverlay(view.canvas, gis.bbox2bounds(bbox)).addTo(map)

            const anim = new Animator(
                () => {
                    model.step()
                    view.draw()
                    // if (model.ticks === 10) view.downloadCanvas()
                },
                500,// -1, // 500, // run 500 steps
                30 // 10 // 30 // 30 fps
            ).startStats()

            util.toWindow({ model, view, modelLayer, anim })
        }
        await setupModelView(elementBounds)


        // ================ mouse drag bbox rect ================

        const mapMouseDownFcn = (ev) => {
            if (ev.originalEvent.altKey) {
                leafletUtils.mouseBounds(L, map, ev, async (elementBounds) => {
                    await setupModelView(elementBounds)
                })
            }
        }
        map.on('mousedown', mapMouseDownFcn)

        const mapKeyFcn = async (ev) => {
            console.log('key', ev.originalEvent)
            if (ev.originalEvent.key === 'm') {
                elementBounds = map.getBounds()
                await setupModelView(elementBounds)

            }
        }
        map.on('keypress', mapKeyFcn)


    </script>
</body>

</html>