<html>

<head>
    <title>Droplets</title>

    <link rel="stylesheet" href="https://cdn.skypack.dev/leaflet@1.8.0-beta.3/dist/leaflet.css">
    <!-- <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0-beta.3/dist/leaflet.css"> -->

    <style>
        * {
            padding: 0;
            margin: 0;
        }

        #map {
            height: 100vh;
            /* z-index: -1; */
        }

        .terrain-pane .leaflet-tile {
            border: solid black 1px;
        }

        .leaflet-container {
            isolation: isolate;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script type="module">
        import * as util from '../src/utils.js'

        import * as gis from '../src/gis.js'
        import * as TileData from '../src/TileData.js'
        import * as leafletUtils from './leafletUtils.js'
        import LeafletDataSet from './LeafletDataSet.js'

        import TwoDraw from '../src/TwoDraw.js'
        import Animator from '../src/Animator.js'
        import GUI from '../src/GUI.js'
        // import dat from 'https://cdn.skypack.dev/dat.gui'

        import Model from '../models/DropletsModel.js'

        // import leafletImage from 'https://cdn.skypack.dev/leaflet-image'
        // import domtoimage from 'https://cdn.skypack.dev/dom-to-image'
        // import html2canvas from 'https://cdn.skypack.dev/html2canvas'

        // import L from 'https://cdn.skypack.dev/leaflet'
        import * as L from 'https://cdn.skypack.dev/leaflet@1.8.0-beta.3/dist/leaflet-src.esm.js'
        // import * as L from 'https://unpkg.com/leaflet@1.8.0-beta.3/dist/leaflet-src.esm.js'
        // import * as L from 'https://unpkg.com/leaflet@1.8.0/dist/leaflet-src.esm.js'

        import elementOverlay from 'https://cdn.skypack.dev/@redfish/leafletelementoverlay'

        util.toWindow({ L, util, gis, LeafletDataSet, leafletUtils })

        const ElementOverlay = elementOverlay(L)
        const tileData = TileData['mapzen'] // redfishUSA/World, mapzen, mapbox
        const terrainName = 'topo'
        util.toWindow({ ElementOverlay, TileData, tileData })

        // ================ create map with terrain & elevation ================

        const center = [35.67, -105.93]
        const Z = 10
        const map = L.map('map', {
            zoomDelta: 0.25, //0.1
            zoomSnap: 0,
            preferCanvas: true,
            // renderer: L.canvas()
        }).setView(center, Z)

        const terrainLayer = L.tileLayer(gis.template(terrainName), {
            attribution: gis.attribution(terrainName),
            className: 'terrain-pane' // shows tiles borders
        }).addTo(map)

        const elevationLayer = L.tileLayer(
            tileData.zxyTemplate,
            {
                opacity: 0.3,
                attribution: 'Elevation Tiles',
                crossOrigin: '',
                maxZoom: tileData.maxZoom, // larger mapzen zoom yields tileerror
            }
        ).addTo(map)
        util.toWindow({ terrainLayer, elevationLayer, map })

        // ================ create dataset from bbox tiles ================

        let leafletDataSet = new LeafletDataSet(
            map,
            elevationLayer,
            tileData
        )
        // leafletUtils.testEvents(map, elevationLayer)
        // leafletUtils.testZooms(elevationLayer)

        // ================ create model using bbox dataset ================

        let modelLayer, elementBounds // = map.getBounds()
        let model, view, anim
        async function setupModelView(bounds = map.getBounds()) {
            elementBounds = bounds
            let bboxDataSet = await leafletDataSet.getBBoxDataSet(bounds)
            console.log('leafletDataSet', leafletDataSet, 'bboxDataSet', bboxDataSet)
            util.toWindow({ leafletDataSet, bboxDataSet, bounds })

            const patchSize = 4

            const worldOptions = {
                minX: 0,
                minY: 0,
                maxX: Math.round(bboxDataSet.width / patchSize) - 1,
                maxY: Math.round(bboxDataSet.height / patchSize) - 1,
            }
            if (model) model.reset(worldOptions)
            else model = new Model(worldOptions)

            model.killOffworld = true // see if faster
            // await model.startup([Z, X, Y]) // TEST
            await model.startup(bboxDataSet)
            model.setup()

            view = new TwoDraw(model, {
                div: util.createCanvas(0, 0), // the view will resize
                patchSize: patchSize,
                useSprites: true,
                drawOptions: {
                    // patchesColor: 'transparent',
                    initPatches: (model, view) =>
                        // view.clear('transparent')
                        model.patches.map(p => p.isLocalMin ? 'black' : 0)
                    ,
                    turtlesShape: 'square',
                    turtlesRotate: false,
                    turtlesColor: 'red',
                    turtlesSize: 0.5

                    // turtlesColor: t => t.patch.isLocalMin ? 'green' : 'red',
                    // turtlesSize: t => t.patch.isLocalMin ? 2.0 : 0.5
                },
            })
            // Note: when zooming happens after adding the canvas, remove the current one
            // and draw it on a new larger canvas with ctx.imageSmoothingEnabled = false
            if (modelLayer) modelLayer.remove()
            view.canvas.style.border = '1px red solid'
            modelLayer = new ElementOverlay(view.canvas, elementBounds).addTo(map)
            // const modelLayer = new ElementOverlay(view.canvas, gis.bbox2bounds(bbox)).addTo(map)

            if (!anim) {
                anim = new Animator(
                    () => {
                        model.step()
                        view.draw()
                        gui.update()
                    },
                    -1, //500,// -1, // 500, // run 500 steps
                    30 // 10 // 30 // 30 fps
                ).startStats('70px') // avoid +/= leaflet control
            } else {
                anim.reset()
            }

            util.toWindow({ model, view, modelLayer, anim })
        }
        await setupModelView(elementBounds)
        // anim = new Animator(
        //     () => {
        //         model.step()
        //         view.draw()
        //         gui.update()
        //     },
        //     -1, //500,// -1, // 500, // run 500 steps
        //     30 // 10 // 30 // 30 fps
        // ).startStats('70px') // avoid +/= leaflet control

        // did not use opacity, so just showed tiles as images
        // leafletImage(map, (err, canvas) => {
        //     util.downloadCanvas(canvas)
        // })
        // prob getting skypack style sheet
        // domtoimage.toBlob(document.getElementById('map')).then(blob => window.foo = blob)
        // similar opacity problems
        // can = await html2canvas(document.getElementById('map'))
        // document.body.appendChild(can)

        // ================ mouse drag bbox rect ================

        const mapMouseDownFcn = (ev) => {
            if (ev.originalEvent.altKey) {
                leafletUtils.mouseBounds(L, map, ev, async (bounds) => {
                    await setupModelView(bounds)
                })
            }
        }
        map.on('mousedown', mapMouseDownFcn)

        const mapKeyFcn = async (ev) => {
            console.log('key', ev.originalEvent)
            if (ev.originalEvent.key === 'm') {
                // elementBounds = map.getBounds()
                await setupModelView()
            }
        }
        // map.on('keypress', mapKeyFcn)

        // ================ gui ================

        const gui = new GUI({
            restartMap: { // button
                cmd: async () => {
                    const stepType = model.stepType
                    await setupModelView()
                    model.stepType = stepType
                    gui.controllers.pause.name('pause')
                    // val => (model.stepType = val)
                }
            },
            pause: { // button
                cmd: () => {
                    const isRunning = anim.isRunning()
                    gui.controllers.pause.name(isRunning ? 'resume' : 'pause')
                    isRunning ? anim.stop() : anim.start()
                },
            },
            stepType: { // chooser
                val: [model.stepType,
                ['minNeighbor', 'patchAspect', 'dataSetAspectNearest', 'dataSetAspectBilinear',
                ]],
                cmd: val => (model.stepType = val),
            },

            mapFolder: 'Map Functions',
            puddleDepth: {
                val: [model.puddleDepth, [1, 15, 1]],
                cmd: async val => {
                    model.puddleDepth = val
                    // await setupModelView()
                    // model.reset(); model.setup()
                }
            },
            opacity: { // slider
                val: [elevationLayer.options.opacity, [0, 1, 0.1]],
                cmd: val => elevationLayer.setOpacity(val),
            },

            modelFolder: 'Model Functions',
            modelTicks: { // monitor
                val: 'listen',
                cmd: () => model.ticks,
            },
            turtles: { // monitor
                val: 'listen',
                cmd: () => model.turtles.length,
            },
            turtlesSize: { // slider
                val: [0.5, [.2, 1, 0.1]],
                cmd: val => view.drawOptions.turtlesSize = val,
            },
            turtlesSpeed: { // slider
                val: [model.speed, [0.2, 1, 0.1]],
                cmd: val => model.speed = val,
            },
            // turtlesColor: { // color
            //     val: '#ff0000',
            //     cmd: val => {
            //         view.drawOptions.turtlesColor = val
            //         if (!anim.isRunning()) view.draw()
            //     },
            // },
            moves: {
                val: 'listen',
                cmd: () => model.steps
            },

            dataFolder: 'Data Functions',
            getElevations: { // button
                cmd: () => util.downloadBlob(bboxDataSet, 'elevations.json', false),
            },
            patchesAspect: { // button
                cmd: () => {
                    const dataSet = model.patches.exportDataSet('aspect')
                    dataSet.bounds = elementBounds
                    util.downloadBlob(dataSet, 'patchesAspect.json', false)
                }
            },
            turtlesData: { // button
                cmd: () => {
                    const data = model.turtles.map(t => {
                        let { heading, x, y } = t
                        const obj = { heading, x, y }
                        util.forLoop(obj, (val, key) => obj[key] = Math.round(val))
                        return obj
                    })
                    util.downloadBlob(data, 'turtlesData.json', false)
                }
            },
        })
        util.forLoop(gui.folders, (val, key) => val.open())

        util.toWindow({ GUI: gui.GUI, gui })

    </script>
</body>

</html>

<!--
        // gui.add(values, 'pause')
        //     .onChange((pause) => {
        //         if (pause) anim.stop(); else anim.start()
        //     })

        // model = new Model({
        // minX: 0,
        // minY: 0,
        // maxX: Math.round(bboxDataSet.width / 4) - 1,
        // maxY: Math.round(bboxDataSet.height / 4) - 1,
        // })

    // const gui = new dat.GUI()

    // util.toWindow({ dat, gui })

    // const values = {
    // opacity: elevationLayer.options.opacity,
    // toggle: () => anim.toggle(),
    // download: () => util.downloadBlob(bboxDataSet, 'ds.txt')
    // // download: 'map',
    // // pause: false
    // }
    // gui.add(values, 'opacity', 0, 1, 0.1)
    // .onChange(opacity => elevationLayer.setOpacity(opacity))
    // gui.add(values, 'toggle')
    // gui.add(values, 'download')
    // // gui.add(values, 'download', ['map', 'elevations'])
    // // .onChange(download => {
    // // switch (download) {
    // // case map:

    // // break;

    // // default:
    // // break;
    // // }
    // // })

 -->