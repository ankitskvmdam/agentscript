<html>

<head>
    <title>Droplets</title>

    <link rel="stylesheet" href="https://cdn.skypack.dev/leaflet@1.8.0-beta.3/dist/leaflet.css">
    <!-- <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0-beta.3/dist/leaflet.css"> -->

    <style>
        * {
            padding: 0;
            margin: 0;
        }

        #map {
            height: 100vh
        }

        .terrain-pane .leaflet-tile {
            border: solid black 1px;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script type="module">
        import * as util from '../src/utils.js'
        import * as gis from '../src/gis.js'
        import * as TileData from '../src/TileData.js'
        import * as leafletUtils from './leafletUtils.js'

        import TwoDraw from '../src/TwoDraw.js'
        import Animator from '../src/Animator.js'
        import Model from '../models/DropletsModel.js'


        // import L from 'https://cdn.skypack.dev/leaflet@1.8.0-beta.3'
        import * as L from 'https://cdn.skypack.dev/leaflet@1.8.0-beta.3/dist/leaflet-src.esm.js'
        // import * as L from 'https://unpkg.com/leaflet@1.8.0-beta.3/dist/leaflet-src.esm.js'

        import elementOverlay from 'https://cdn.skypack.dev/@redfish/leafletelementoverlay'

        import LeafletDataSet from './LeafletDataSet.js'

        // util.toWindow({ L, util, gis, LeafletDataSet, leafletUtils })


        const ElementOverlay = elementOverlay(L)
        const tileData = TileData['mapzen'] // redfishUSA/World, mapzen, mapbox
        const terrainName = 'topo'
        util.toWindow({ TileData, tileData, leafletUtils })

        // ================ setup parameters ================

        // let { X, Y, Z } = { X: 210, Y: 403, Z: 10 }
        // const bbox = gis.xyz2bbox(X, Y, Z)
        // const bboxCenter = gis.latlon(gis.bboxCenter(bbox))
        // console.log('XYZ', X, Y, Z, 'bbox', bbox, 'center', bboxCenter)
        // util.toWindow({ X, Y, Z })

        const center = [35.67, -105.93]
        const Z = 10

        // ================ create map with terrain & elevation ================

        const map = L.map('map', {
            zoomDelta: 0.25, //0.1
            zoomSnap: 0,
            // }).setView(bboxCenter, Z)
        }).setView(center, Z)

        const terrainLayer = L.tileLayer(gis.template(terrainName), {
            attribution: gis.attribution(terrainName),
            className: 'terrain-pane' // shows tiles borders
        }).addTo(map)

        const elevationLayer = L.tileLayer(
            tileData.zxyTemplate,
            {
                opacity: 0.1,
                // opacity: 1,
                attribution: 'Elevation Tiles',
                crossOrigin: '',
                maxZoom: tileData.maxZoom, // larger mapzen zoom yields tileerror
            }
        ).addTo(map)
        util.toWindow({ terrainLayer, elevationLayer, map })

        // ================ create dataset from bbox tiles ================

        let leafletDataSet = new LeafletDataSet(
            map,
            elevationLayer,
            tileData
        )
        leafletUtils.testEvents(map, elevationLayer)
        // leafletUtils.testZooms(elevationLayer)

        // let [lon, lat, Z] = [-105.645, 35.889, 11]
        // let bbox = gis.lonLatz2bbox(lon, lat, Z)

        // let bboxDataSet = await leafletDataSet.getBBoxDataSet(bbox)
        let bboxDataSet = await leafletDataSet.getBBoxDataSet()

        // let tileName = leafletDataSet.tileName({ x: X, y: Y, z: Z })
        // let tile = leafletDataSet.tiles[tileName]

        // const [lon, lat] = gis.bboxCenter(bbox)
        // const [x, y, z] = gis.lonlatz2xyz(lon, lat, this.getZoom())
        // const name = this.tileName({ x, y, z })
        // const dataSet = this.tiles[name]
        // return dataSet

        console.log('leafletDataSet', leafletDataSet, 'bboxDataSet', bboxDataSet)
        util.toWindow({ leafletDataSet, bboxDataSet })

        // ================ create model using bbox dataset ================

        const model = new Model({
            minX: 0,
            minY: 0,
            maxX: Math.round(bboxDataSet.width / 4) - 1,
            maxY: Math.round(bboxDataSet.height / 4) - 1,
            // maxX: bboxDataSet.width - 1,
            // maxY: bboxDataSet.height - 1,
        })
        model.killOffworld = true // see if faster
        // await model.startup([Z, X, Y]) // TEST
        await model.startup(bboxDataSet)
        model.setup()
        const view = new TwoDraw(model, {
            div: util.createCanvas(0, 0), // the view will resize
            patchSize: 4,
            // useSprites: true,
            drawOptions: {
                patchesColor: 'transparent',
                turtlesShape: 'square',
                turtlesRotate: false,
                turtlesColor: 'red',
                turtlesSize: 0.5, //1,
            },
        })
        // Note: when zooming happens after adding the canvas, remove the current one
        // and draw it on a new larger canvas with ctx.imageSmoothingEnabled = false
        const modelLayer = new ElementOverlay(view.canvas, map.getBounds()).addTo(map)
        // const modelLayer = new ElementOverlay(view.canvas, gis.bbox2bounds(bbox)).addTo(map)

        const anim = new Animator(
            () => {
                model.step()
                view.draw()
                // if (model.ticks === 10) view.downloadCanvas()
            },
            500,// -1, // 500, // run 500 steps
            30 // 10 // 30 // 30 fps
        ).startStats()

        util.toWindow({ model, view, modelLayer, anim })

        // ================ mouse drag bbox rect ================

        const mapMouseDownFcn = (ev) => {
            console.log('mapMouseDownFcn')
            leafletUtils.eventKeys(ev)
            if (ev.originalEvent.altKey) leafletUtils.mouseBounds(L, map, ev)
        }
        map.on('mousedown', mapMouseDownFcn)


    </script>
</body>

</html>